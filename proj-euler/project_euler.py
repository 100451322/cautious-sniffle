# -*- coding: utf-8 -*-
"""project euler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_EmEaZOLdis5T3SOydHkImFHBN0K3zlo

**PROJECT EULER.NET**

VAMOS A LOS QUE PODAMOS :)

[Project Euler](https://projecteuler.net)

# PROBLEMA 1


If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.
"""

# MI IMPLEMENTACIÓN

suma = 0
for i in range(1000):
  if i%3 == 0 or i%5 == 0:
    suma += i
print(suma)

# MANERA INTELIGENTE

n = 999

def suma_divisibles(num, total):
  """Suma todos los números divisibles por num hasta total"""
  p = total // num
  return num * (p + 1) * p // 2

print(suma_divisibles(3, n) + suma_divisibles(5, n) - suma_divisibles(15, n))

"""# PROBLEMA 2
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
"""

fib = [1,2]
suma = 2

while True:
  i = fib[-1] + fib[-2]
  if i > 4000000:
    break
  fib.append(i)
  if i%2 == 0:
    suma += i

print(suma)

"""# PROBLEMA 3
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
"""

from math import sqrt

def check_prime(number):
  """Devuelve una lista con todos los divisores de number, no funciona bien para números pequeños"""
  r = int(sqrt(number))
  l = []
  for i in range(r):
    if i == 0:
      continue
    if number%i == 0:
      l.append(i)
  return l

num = 600851475143

it1 = check_prime(num)
print(it1)
for i in it1:
  a = check_prime(i)
  print(i, a)

from math import sqrt

number = 2**56

def max_prime(n):
  """Devuelve el factor número primo más grande de n"""
  if n%2 == 0:
    lastFactor = 2
    n = n // 2
    while n%2 == 0:
      n = n // 2
  else:
    lastFactor = 1
  factor = 3

  maxFactor = int(sqrt(n))

  while n > 1 and factor <= maxFactor:
    if n % factor == 0:
      n = n//factor
      lastFactor = factor
      while n%factor == 0:
        n = n%factor
      maxFactor = int(sqrt(n))
    factor += 2
  if n == 1:
    return lastFactor
  else:
    return n

max_prime(number)

"""# PROBLEMA 4
 

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.

"""

def check_palindrome(n):
  """Comprueba si un número es un palindromo (también funciona para strings y floats)"""
  return str(n) == str(n)[::-1]

maxPalindrome = 0
for i in range(1000,100,-1):
  for j in range(1000,100,-1):
    prod = i*j
    if check_palindrome(prod):
      if prod > maxPalindrome:
        maxPalindrome = prod
print(maxPalindrome)

"""# PROBLEMA 5


2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

"""

def mcd(a,b):
  """Devuelve el máximo común divisor de a y b"""
  if a == 0 or b == 0:
    return max(a,b)
  else:
    if a > b:
      return mcd(b, a%b)
    else: # b > a
      return mcd(a, b%a)

def mcm(a,b):
  """Devuelve el mínimo común múltiplo de a y b , depende de la función mcd"""
  return abs(a*b) // mcd(a,b)

p = 20
smallest = 1
for i in range(1,p +1):
  smallest = mcm(smallest,i)

print(smallest)

"""# PROBLEMA 6

The sum of the squares of the first ten natural numbers is,

1²*+2²+...+10²=385

The square of the sum of the first ten natural numbers is,

(1+2+...+10)²=55²=3025

Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025-385=2640.

Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
"""

def sum_euler(n):
  """Suma de todos los números de 1 a n"""
  return (n+1)*n//2

def sum_cuadrados(n):
  """Suma del cuadrado de todos los números de 1 a n"""
  return (2*n+1)*(n+1)*n // 6

sq_sum = 0
for i in range(100):
  sq_sum += (i+1)**2

print(sum_euler(100)**2 - sum_cuadrados(100))

"""# PROBLEMA 7


By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?

"""

# Esto es fuerza bruta
l = [2]
n = 3
while len(l)<10001:
  is_prime = True
  for j in l:
    if n%j == 0:
      is_prime = False
  if is_prime:
    l.append(n)
  n += 1

print(l[-1])

"""# PROBLEMA 8


The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

"""

def mult_digits(n):
  """Devuelve el producto de los dígitos del número"""
  prod = 1
  for i in str(n):
    prod *= int(i)
  return prod

n = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

last_digit = 0
next_digit = 13
largest = 0
while next_digit < 1000:
  num = n[last_digit:next_digit]
  largest = max(largest, mult_digits(num))
  last_digit += 1
  next_digit += 1

print(largest)

"""# PROBLEMA 9

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,


> a²+b² = c²

For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.

Find the product abc.


"""

def is_pythagoras(a, b, c):
  # a^2 + b^2 = c^2
  return a + b == c


for a in range(400):
  a2 = a**2
  for b in range(500):
    b2 = b**2
    for c in range(600):
      c2 = c**2
      if is_pythagoras(a2, b2, c2):
        if a + b + c == 1000 and a < b and b < c:
          print(a, b, c, a*b*c)

"""# PROBLEMA 10

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.
"""

from math import sqrt

def is_prime(n): # Basado en la solución al ejercicio 7
  if n == 1:
    return False
  if n % 2 == 0:
    return False
  if n % 3 == 0:
    return False
  else:
    r = int(sqrt(n))
    f = 5
    while f <= r:
      if n % f == 0: # 6*k - 1
        return False
      if n % (f+2) == 0: # 6*k + 1
        return False
      f += 6
    return True


suma = 2 + 3 + 5 + 7 # 17
n = 10
while n < 2000000:
  if is_prime(n):
    suma += n
  n += 1

print(suma)

"""https://projecteuler.net/problem=10"""