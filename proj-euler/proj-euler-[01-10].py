# -*- coding: utf-8 -*-
"""
VAMOS A POR LOS QUE PODAMOS :)
"""

from math import sqrt


# PROBLEMA 1
"""
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
"""

## IMPLEMENTACIÓN NAIVE
def prob1(n):
    suma = 0
    for i in range(n):
        if i % 3 == 0 or i % 5 == 0:
            suma += i
    print("Solución:", suma)

## IMPLEMENTACIÓN MEJORADA
def suma_divisibles(num, total):
  """Suma todos los números divisibles por num hasta total"""
  p = total // num
  return num * (p + 1) * p // 2

def prob1_op(n):
    """El problema se puede simplificar usando el principio de inclusión exclusión: A⋃B=A+B-A⋂B"""
    print("Solución:", suma_divisibles(3, n) + suma_divisibles(5, n) - suma_divisibles(15, n))



# PROBLEMA 2
"""
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
"""

def prob2(n):
    """Suma de los números de fibonacci pares hasta n"""
    fib = [1,2]
    suma = 2

    while True:
        i = fib[-1] + fib[-2]
        if i > n:
            break
        fib.append(i)
        if i % 2 == 0:
            suma += i

    print("Solución:", suma)



# PROBLEMA 3
"""
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?
"""

# IMPLEMENTACIÓN NAIVE
def check_prime(number):
  """Devuelve una lista con todos los divisores de number, no funciona a veces"""
  r = int(sqrt(number))
  l = []
  for i in range(r):
    if i == 0:
      continue
    if number % i == 0:
      l.append(i)
  return l

def prob3(num):
    """Primero miramos (imprimimos) los divisores de num y luego miramos los divisores de sus divisores"""
    it1 = check_prime(num)
    print(it1)
    for i in it1:
        a = check_prime(i)
        print(i, a)

# IMPLEMENTACIÓN MEJORADA
def max_prime(n):
  """Devuelve el factor número primo más grande de n"""
  if n % 2 == 0:
    lastFactor = 2
    n = n // 2
    while n%2 == 0:
      n = n // 2
  else:
    lastFactor = 1
  factor = 3

  maxFactor = int(sqrt(n))

  while n > 1 and factor <= maxFactor:
    if n % factor == 0:
      n = n//factor
      lastFactor = factor
      while n%factor == 0:
        n = n%factor
      maxFactor = int(sqrt(n))
    factor += 2
  if n == 1:
    return lastFactor
  else:
    return n

def prob3_op(number):
    print("Solución:", max_prime(number))



# PROBLEMA 4
"""
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.
"""

def check_palindrome(n):
  """Comprueba si un número es un palindromo (también funciona para strings y floats)"""
  return str(n) == str(n)[::-1]

def prob4(inicio, fin):
    """Recibe el número de cifras que tienen los números"""
    maxPalindrome = 0

    # Empezando por el final llegamos a la solución antes
    for i in range(fin, inicio, -1):
        for j in range(fin, inicio, -1):
            prod = i*j
            if check_palindrome(prod):
                if prod > maxPalindrome:
                    maxPalindrome = prod

    print("Solución:", maxPalindrome)




"""# PROBLEMA 5
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
"""

def mcd(a,b):
  """Devuelve el máximo común divisor de a y b (Método de Euclides)"""
  if a == 0 or b == 0:
    return max(a,b)
  else:
    if a > b:
      return mcd(b, a%b)
    else: # b >= a
      return mcd(a, b%a)

def mcm(a,b):
  """Devuelve el mínimo común múltiplo de a y b , depende de la función mcd"""
  return abs(a*b) // mcd(a,b)

def prob5(n):
    """Devuelve cual es el divisor más pequeño de n"""
    smallest = 1
    for i in range(1, n + 1):
        smallest = mcm(smallest, i)

    print("Solución:", smallest)


# PROBLEMA 6
"""
The sum of the squares of the first ten natural numbers is,
    1² + 2² + ... + 10² = 385
The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)² = 55² = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025-385=2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
"""

def sum_euler(n):
  """Suma de todos los números de 1 a n"""
  return (n+1)*n//2

def sum_cuadrados(n):
    suma = 0
    for i in range(n):
        suma += (i + 1)**2
    return suma

def prob6(n):
    print("Solución:", sum_euler(100)**2 - sum_cuadrados(100))

def sum_cuadrados_op(n):
  """Suma del cuadrado de todos los números de 1 a n (https://es.wikipedia.org/wiki/N%C3%BAmero_piramidal_cuadrado"""
  return (2*n+1)*(n+1)*n // 6

def prob6_op(n):
    print("Solución:", sum_euler(100)**2 - sum_cuadrados_op(100))



# PROBLEMA 7
"""
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10 001st prime number?
"""

# Esto es basicamente fuerza bruta
def prob7(num):
    l = [2]
    n = 3
    while len(l) < num:
        is_prime = True
        for j in l:
            if n%j == 0:
                is_prime = False
        if is_prime:
                l.append(n)
        n += 1

    print("Solución:", l[-1])



# PROBLEMA 8
"""
The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

"""

def mult_digits(n):
  """Devuelve el producto de los dígitos del número"""
  prod = 1
  for i in str(n):
    prod *= int(i)
  return prod

num_prob8 = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

def prob8(n, i):
    """Va mirando el producto de los digitos de n en intervalos de i cifras"""
    last_digit = 0
    next_digit = i
    largest = 0
    while next_digit < len(n):
        num = n[last_digit:next_digit]
        largest = max(largest, mult_digits(num))
        last_digit += 1
        next_digit += 1

    print("Solución:", largest)



# PROBLEMA 9
"""
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    a²+b² = c²
For example, 32 + 42 = 9 + 16 = 25 = 52.
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
"""

def is_pythagoras(a, b, c):
  # a^2 + b^2 = c^2
  return a + b == c

def prob9(n):
  for a in range(400):
      a2 = a**2
      for b in range(500):
          b2 = b**2
          for c in range(600):
              c2 = c**2
              if is_pythagoras(a2, b2, c2):
                  if a + b + c == 1000 and a < b and b < c:
                      print("Números", a, b, c)
                      print("Solución:", a*b*c)



# PROBLEMA 10
"""
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
"""

def is_prime(n): # Basado en la solución al ejercicio 7
  if n == 1:
    return False
  if n % 2 == 0:
    return False
  if n % 3 == 0:
    return False
  else:
    r = int(sqrt(n))
    f = 5
    while f <= r:
      if n % f == 0: # 6*k - 1
        return False
      if n % (f+2) == 0: # 6*k + 1
        return False
      f += 6
    return True

def prob10(number):
    suma = 2 + 3 + 5 + 7 # 17
    n = 10
    while n < number:
        if is_prime(n):
            suma += n
        n += 1
 
    print("Solución:", suma)




## AHORA LOS EJECUTAMOS

# prob1(1000)
# prob1_op(999)
# prob2(4_000_000)
# prob3(600851475143)
# prob3_op(600851475143)
# prob4(100, 1000)
# prob5(20)
# prob6(100)
# prob7(10_001)
# prob8(num_prob8)
# prob9(1000)
# prob10(2_000_000)
